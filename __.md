
Pending logig:
Οταν ένα request τουπου απαιτεί τη συνεργασία των γόρκερς φτάνει από τον πελάτη στο μάστερ, 
ο μάστερ δεν κλείνει τη σύνδεση με τον client, 
πρώτα περιμένει να ολοκληρωθεί η διαδρομή από τους γόρκερς στο ρεντιουσερ κ πισω στο μάστερ,
κ τότε, όταν δηλαδή επιστρέφει ο ρεντιουσερ στον μαστερ, επιστρέφει το αποτέλεσμα πίσω στον ξλαιεντ από
την σύνδεση που παρέμεινε ανοιχτή, κ μετά την κλείνει.

Τα αιτήματα που εκρεμούν διατηρούνται σε μια λήστα που τα αντιστοιχέι με το id του αιτήματος
(όχι το ID του τύπου του αιτήματος, το ID του αιτήματος clientTaskID). Τo id αυτό
χρησιμοποιείται για να μπορεί να αναγνωρίζεται κ εντοπίζεται ποιο αίτημα είναι
αυτό που περιμένει
 public Answer handleRequestFromClient(Task req) {
    ...
    Pending pending = new Pending();
    addPending(taskID, pending);
    ...
    Answer answer = pending.waitForAnswer();
    return answer
 }

 public class InnerMaster implements RequestHandler {
        @Override
        public Answer handleRequestFromClient(Task req) {
            ...
            Pending pending = getPending(taskID);
            ...
            pending.setAnswer(answer); // σε αυτό το σημείο συνεχίζει ο κώδικας που περιμένει παραπάνω
            ...

        }
 }

 public class Pending {
    public Answer answer;
    public boolean isSet = false;

    public synchronized Answer waitForAnswer() {
        while (!isSet) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
                return null;
            }
        }
        return answer;
    }

    public synchronized void setAnswer(Answer answer) {
        if (!isSet) {
            this.answer = answer;
            this.isSet = true;
            notify();  // Wake up waiting thread
        }
    }
    
}

